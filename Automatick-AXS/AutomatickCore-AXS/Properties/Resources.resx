<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="Flag16Disable" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Flag16Disable.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Automatic481" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Automatic48.ico;System.Drawing.Icon, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Automatic32" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Automatic32.ico;System.Drawing.Icon, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="TicketFound" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\TicketFound.wav;System.IO.MemoryStream, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="favicon_16x16" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\favicon_16x16.ico;System.Drawing.Icon, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="EmailBody" xml:space="preserve">
    <value>&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;table width="600" style="border: 1px #d9d9d9 solid; background:no-repeat; background-position:right bottom; border="0" cellspacing="0" cellpadding="0" align="center"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td height="600" valign="top"&gt;&lt;table width="600" border="0" cellspacing="0" cellpadding="0"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align="center"&gt;&lt;table width="90%" border="0" cellspacing="0" cellpadding="0"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="font-family:Arial, Helvetica, sans-serif; font-size:36px; color:#868686;" align="center"&gt;Ticket Found&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td height="13" style="border-bottom: 1px #CCCCCC dashed;"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align="center"&gt;&lt;table width="90%" border="0" cellspacing="0" cellpadding="0" style="font-family:Arial, Helvetica, sans-serif; font-size: 16px; line-height:30px; color:#414141;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Event:&lt;/td&gt;&lt;td style="color:#868686;"&gt;{0}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Quantity:&lt;/td&gt;&lt;td style="color:#868686;"&gt;{1}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Section:&lt;/td&gt;&lt;td style="color:#868686;"&gt;{2}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Row:&lt;/td&gt;&lt;td style="color:#868686;"&gt;{3}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Seat(s):&lt;/td&gt;&lt;td style="color:#868686;"&gt;{4}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Price:&lt;/td&gt;&lt;td style="color:#868686;"&gt;{5}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Event url/link:&lt;/td&gt;&lt;td&gt;&lt;a href="{6}" style="color:#90b2cf; text-decoration:none;"&gt;{7}&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</value>
  </data>
  <data name="WorldPay" xml:space="preserve">
    <value>//  Copyright (c) 2015 Worldpay. All rights reserved.
//
//  License information can be found here: https://github.com/Worldpay/worldpay-cse-lib-javascript/blob/master/LICENSE

!function (a, b) {
    "use strict";
    function c(a) {
        throw a
    }
    function d(a, b, d) {
        4 !== b.length &amp;&amp; c(new Oa.exception.invalid("invalid aes block size"));
        var e = a.b[d]
          , f = b[0] ^ e[0]
          , g = b[d ? 3 : 1] ^ e[1]
          , h = b[2] ^ e[2];
        b = b[d ? 1 : 3] ^ e[3];
        var i, j, k, l, m = e.length / 4 - 2, n = 4, o = [0, 0, 0, 0];
        i = a.k[d],
        a = i[0];
        var p = i[1]
          , q = i[2]
          , r = i[3]
          , s = i[4];
        for (l = 0; m &gt; l; l++)
            i = a[f &gt;&gt;&gt; 24] ^ p[g &gt;&gt; 16 &amp; 255] ^ q[h &gt;&gt; 8 &amp; 255] ^ r[255 &amp; b] ^ e[n],
            j = a[g &gt;&gt;&gt; 24] ^ p[h &gt;&gt; 16 &amp; 255] ^ q[b &gt;&gt; 8 &amp; 255] ^ r[255 &amp; f] ^ e[n + 1],
            k = a[h &gt;&gt;&gt; 24] ^ p[b &gt;&gt; 16 &amp; 255] ^ q[f &gt;&gt; 8 &amp; 255] ^ r[255 &amp; g] ^ e[n + 2],
            b = a[b &gt;&gt;&gt; 24] ^ p[f &gt;&gt; 16 &amp; 255] ^ q[g &gt;&gt; 8 &amp; 255] ^ r[255 &amp; h] ^ e[n + 3],
            n += 4,
            f = i,
            g = j,
            h = k;
        for (l = 0; 4 &gt; l; l++)
            o[d ? 3 &amp; -l : l] = s[f &gt;&gt;&gt; 24] &lt;&lt; 24 ^ s[g &gt;&gt; 16 &amp; 255] &lt;&lt; 16 ^ s[h &gt;&gt; 8 &amp; 255] &lt;&lt; 8 ^ s[255 &amp; b] ^ e[n++],
            i = f,
            f = g,
            g = h,
            h = b,
            b = i;
        return o
    }
    function e(a, b) {
        var c, d, e, f = b.slice(0), g = a.r, h = a.b, i = g[0], j = g[1], k = g[2], l = g[3], m = g[4], n = g[5], o = g[6], p = g[7];
        for (c = 0; 64 &gt; c; c++)
            16 &gt; c ? d = f[c] : (d = f[c + 1 &amp; 15],
            e = f[c + 14 &amp; 15],
            d = f[15 &amp; c] = (d &gt;&gt;&gt; 7 ^ d &gt;&gt;&gt; 18 ^ d &gt;&gt;&gt; 3 ^ d &lt;&lt; 25 ^ d &lt;&lt; 14) + (e &gt;&gt;&gt; 17 ^ e &gt;&gt;&gt; 19 ^ e &gt;&gt;&gt; 10 ^ e &lt;&lt; 15 ^ e &lt;&lt; 13) + f[15 &amp; c] + f[c + 9 &amp; 15] | 0),
            d = d + p + (m &gt;&gt;&gt; 6 ^ m &gt;&gt;&gt; 11 ^ m &gt;&gt;&gt; 25 ^ m &lt;&lt; 26 ^ m &lt;&lt; 21 ^ m &lt;&lt; 7) + (o ^ m &amp; (n ^ o)) + h[c],
            p = o,
            o = n,
            n = m,
            m = l + d | 0,
            l = k,
            k = j,
            j = i,
            i = d + (j &amp; k ^ l &amp; (j ^ k)) + (j &gt;&gt;&gt; 2 ^ j &gt;&gt;&gt; 13 ^ j &gt;&gt;&gt; 22 ^ j &lt;&lt; 30 ^ j &lt;&lt; 19 ^ j &lt;&lt; 10) | 0;
        g[0] = g[0] + i | 0,
        g[1] = g[1] + j | 0,
        g[2] = g[2] + k | 0,
        g[3] = g[3] + l | 0,
        g[4] = g[4] + m | 0,
        g[5] = g[5] + n | 0,
        g[6] = g[6] + o | 0,
        g[7] = g[7] + p | 0
    }
    function f(a, b) {
        var c, d = Oa.random.w[a], e = [];
        for (c in d)
            d.hasOwnProperty(c) &amp;&amp; e.push(d[c]);
        for (c = 0; c &lt; e.length; c++)
            e[c](b)
    }
    function g(a) {
        "undefined" != typeof window &amp;&amp; window.performance &amp;&amp; "function" == typeof window.performance.now ? Oa.random.addEntropy(window.performance.now(), a, "loadtime") : Oa.random.addEntropy((new Date).valueOf(), a, "loadtime")
    }
    function h(a) {
        a.b = i(a).concat(i(a)),
        a.A = new Oa.cipher.aes(a.b)
    }
    function i(a) {
        for (var b = 0; 4 &gt; b &amp;&amp; (a.f[b] = a.f[b] + 1 | 0,
        !a.f[b]) ; b++)
            ;
        return a.A.encrypt(a.f)
    }
    function j(a, b) {
        return function () {
            b.apply(a, arguments)
        }
    }
    function k(a, b, c) {
        null != a &amp;&amp; ("number" == typeof a ? this.fromNumber(a, b, c) : null == b &amp;&amp; "string" != typeof a ? this.fromString(a, 256) : this.fromString(a, b))
    }
    function l() {
        return new k(null)
    }
    function m(a, b, c, d, e, f) {
        for (; --f &gt;= 0;) {
            var g = b * this[a++] + c[d] + e;
            e = Math.floor(g / 67108864),
            c[d++] = 67108863 &amp; g
        }
        return e
    }
    function n(a, b, c, d, e, f) {
        for (var g = 32767 &amp; b, h = b &gt;&gt; 15; --f &gt;= 0;) {
            var i = 32767 &amp; this[a]
              , j = this[a++] &gt;&gt; 15
              , k = h * i + j * g;
            i = g * i + ((32767 &amp; k) &lt;&lt; 15) + c[d] + (1073741823 &amp; e),
            e = (i &gt;&gt;&gt; 30) + (k &gt;&gt;&gt; 15) + h * j + (e &gt;&gt;&gt; 30),
            c[d++] = 1073741823 &amp; i
        }
        return e
    }
    function o(a, b, c, d, e, f) {
        for (var g = 16383 &amp; b, h = b &gt;&gt; 14; --f &gt;= 0;) {
            var i = 16383 &amp; this[a]
              , j = this[a++] &gt;&gt; 14
              , k = h * i + j * g;
            i = g * i + ((16383 &amp; k) &lt;&lt; 14) + c[d] + e,
            e = (i &gt;&gt; 28) + (k &gt;&gt; 14) + h * j,
            c[d++] = 268435455 &amp; i
        }
        return e
    }
    function p(a) {
        return bb.charAt(a)
    }
    function q(a, b) {
        var c = cb[a.charCodeAt(b)];
        return null == c ? -1 : c
    }
    function r(a) {
        for (var b = this.t - 1; b &gt;= 0; --b)
            a[b] = this[b];
        a.t = this.t,
        a.s = this.s
    }
    function s(a) {
        this.t = 1,
        this.s = 0 &gt; a ? -1 : 0,
        a &gt; 0 ? this[0] = a : -1 &gt; a ? this[0] = a + this.DV : this.t = 0
    }
    function t(a) {
        var b = l();
        return b.fromInt(a),
        b
    }
    function u(a, b) {
        var c;
        if (16 == b)
            c = 4;
        else if (8 == b)
            c = 3;
        else if (256 == b)
            c = 8;
        else if (2 == b)
            c = 1;
        else if (32 == b)
            c = 5;
        else {
            if (4 != b)
                return void this.fromRadix(a, b);
            c = 2
        }
        this.t = 0,
        this.s = 0;
        for (var d = a.length, e = !1, f = 0; --d &gt;= 0;) {
            var g = 8 == c ? 255 &amp; a[d] : q(a, d);
            0 &gt; g ? "-" == a.charAt(d) &amp;&amp; (e = !0) : (e = !1,
            0 == f ? this[this.t++] = g : f + c &gt; this.DB ? (this[this.t - 1] |= (g &amp; (1 &lt;&lt; this.DB - f) - 1) &lt;&lt; f,
            this[this.t++] = g &gt;&gt; this.DB - f) : this[this.t - 1] |= g &lt;&lt; f,
            f += c,
            f &gt;= this.DB &amp;&amp; (f -= this.DB))
        }
        8 == c &amp;&amp; 0 != (128 &amp; a[0]) &amp;&amp; (this.s = -1,
        f &gt; 0 &amp;&amp; (this[this.t - 1] |= (1 &lt;&lt; this.DB - f) - 1 &lt;&lt; f)),
        this.clamp(),
        e &amp;&amp; k.ZERO.subTo(this, this)
    }
    function v() {
        for (var a = this.s &amp; this.DM; this.t &gt; 0 &amp;&amp; this[this.t - 1] == a;)
            --this.t
    }
    function w(a) {
        if (this.s &lt; 0)
            return "-" + this.negate().toString(a);
        var b;
        if (16 == a)
            b = 4;
        else if (8 == a)
            b = 3;
        else if (2 == a)
            b = 1;
        else if (32 == a)
            b = 5;
        else {
            if (4 != a)
                return this.toRadix(a);
            b = 2
        }
        var c, d = (1 &lt;&lt; b) - 1, e = !1, f = "", g = this.t, h = this.DB - g * this.DB % b;
        if (g-- &gt; 0)
            for (h &lt; this.DB &amp;&amp; (c = this[g] &gt;&gt; h) &gt; 0 &amp;&amp; (e = !0,
            f = p(c)) ; g &gt;= 0;)
                b &gt; h ? (c = (this[g] &amp; (1 &lt;&lt; h) - 1) &lt;&lt; b - h,
                c |= this[--g] &gt;&gt; (h += this.DB - b)) : (c = this[g] &gt;&gt; (h -= b) &amp; d,
                0 &gt;= h &amp;&amp; (h += this.DB,
                --g)),
                c &gt; 0 &amp;&amp; (e = !0),
                e &amp;&amp; (f += p(c));
        return e ? f : "0"
    }
    function x() {
        var a = l();
        return k.ZERO.subTo(this, a),
        a
    }
    function y() {
        return this.s &lt; 0 ? this.negate() : this
    }
    function z(a) {
        var b = this.s - a.s;
        if (0 != b)
            return b;
        var c = this.t;
        if (b = c - a.t,
        0 != b)
            return this.s &lt; 0 ? -b : b;
        for (; --c &gt;= 0;)
            if (0 != (b = this[c] - a[c]))
                return b;
        return 0
    }
    function A(a) {
        var b, c = 1;
        return 0 != (b = a &gt;&gt;&gt; 16) &amp;&amp; (a = b,
        c += 16),
        0 != (b = a &gt;&gt; 8) &amp;&amp; (a = b,
        c += 8),
        0 != (b = a &gt;&gt; 4) &amp;&amp; (a = b,
        c += 4),
        0 != (b = a &gt;&gt; 2) &amp;&amp; (a = b,
        c += 2),
        0 != (b = a &gt;&gt; 1) &amp;&amp; (a = b,
        c += 1),
        c
    }
    function B() {
        return this.t &lt;= 0 ? 0 : this.DB * (this.t - 1) + A(this[this.t - 1] ^ this.s &amp; this.DM)
    }
    function C(a, b) {
        var c;
        for (c = this.t - 1; c &gt;= 0; --c)
            b[c + a] = this[c];
        for (c = a - 1; c &gt;= 0; --c)
            b[c] = 0;
        b.t = this.t + a,
        b.s = this.s
    }
    function D(a, b) {
        for (var c = a; c &lt; this.t; ++c)
            b[c - a] = this[c];
        b.t = Math.max(this.t - a, 0),
        b.s = this.s
    }
    function E(a, b) {
        var c, d = a % this.DB, e = this.DB - d, f = (1 &lt;&lt; e) - 1, g = Math.floor(a / this.DB), h = this.s &lt;&lt; d &amp; this.DM;
        for (c = this.t - 1; c &gt;= 0; --c)
            b[c + g + 1] = this[c] &gt;&gt; e | h,
            h = (this[c] &amp; f) &lt;&lt; d;
        for (c = g - 1; c &gt;= 0; --c)
            b[c] = 0;
        b[g] = h,
        b.t = this.t + g + 1,
        b.s = this.s,
        b.clamp()
    }
    function F(a, b) {
        b.s = this.s;
        var c = Math.floor(a / this.DB);
        if (c &gt;= this.t)
            return void (b.t = 0);
        var d = a % this.DB
          , e = this.DB - d
          , f = (1 &lt;&lt; d) - 1;
        b[0] = this[c] &gt;&gt; d;
        for (var g = c + 1; g &lt; this.t; ++g)
            b[g - c - 1] |= (this[g] &amp; f) &lt;&lt; e,
            b[g - c] = this[g] &gt;&gt; d;
        d &gt; 0 &amp;&amp; (b[this.t - c - 1] |= (this.s &amp; f) &lt;&lt; e),
        b.t = this.t - c,
        b.clamp()
    }
    function G(a, b) {
        for (var c = 0, d = 0, e = Math.min(a.t, this.t) ; e &gt; c;)
            d += this[c] - a[c],
            b[c++] = d &amp; this.DM,
            d &gt;&gt;= this.DB;
        if (a.t &lt; this.t) {
            for (d -= a.s; c &lt; this.t;)
                d += this[c],
                b[c++] = d &amp; this.DM,
                d &gt;&gt;= this.DB;
            d += this.s
        } else {
            for (d += this.s; c &lt; a.t;)
                d -= a[c],
                b[c++] = d &amp; this.DM,
                d &gt;&gt;= this.DB;
            d -= a.s
        }
        b.s = 0 &gt; d ? -1 : 0,
        -1 &gt; d ? b[c++] = this.DV + d : d &gt; 0 &amp;&amp; (b[c++] = d),
        b.t = c,
        b.clamp()
    }
    function H(a, b) {
        var c = this.abs()
          , d = a.abs()
          , e = c.t;
        for (b.t = e + d.t; --e &gt;= 0;)
            b[e] = 0;
        for (e = 0; e &lt; d.t; ++e)
            b[e + c.t] = c.am(0, d[e], b, e, 0, c.t);
        b.s = 0,
        b.clamp(),
        this.s != a.s &amp;&amp; k.ZERO.subTo(b, b)
    }
    function I(a) {
        for (var b = this.abs(), c = a.t = 2 * b.t; --c &gt;= 0;)
            a[c] = 0;
        for (c = 0; c &lt; b.t - 1; ++c) {
            var d = b.am(c, b[c], a, 2 * c, 0, 1);
            (a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, d, b.t - c - 1)) &gt;= b.DV &amp;&amp; (a[c + b.t] -= b.DV,
            a[c + b.t + 1] = 1)
        }
        a.t &gt; 0 &amp;&amp; (a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1)),
        a.s = 0,
        a.clamp()
    }
    function J(a, b, c) {
        var d = a.abs();
        if (!(d.t &lt;= 0)) {
            var e = this.abs();
            if (e.t &lt; d.t)
                return null != b &amp;&amp; b.fromInt(0),
                void (null != c &amp;&amp; this.copyTo(c));
            null == c &amp;&amp; (c = l());
            var f = l()
              , g = this.s
              , h = a.s
              , i = this.DB - A(d[d.t - 1]);
            i &gt; 0 ? (d.lShiftTo(i, f),
            e.lShiftTo(i, c)) : (d.copyTo(f),
            e.copyTo(c));
            var j = f.t
              , m = f[j - 1];
            if (0 != m) {
                var n = m * (1 &lt;&lt; this.F1) + (j &gt; 1 ? f[j - 2] &gt;&gt; this.F2 : 0)
                  , o = this.FV / n
                  , p = (1 &lt;&lt; this.F1) / n
                  , q = 1 &lt;&lt; this.F2
                  , r = c.t
                  , s = r - j
                  , t = null == b ? l() : b;
                for (f.dlShiftTo(s, t),
                c.compareTo(t) &gt;= 0 &amp;&amp; (c[c.t++] = 1,
                c.subTo(t, c)),
                k.ONE.dlShiftTo(j, t),
                t.subTo(f, f) ; f.t &lt; j;)
                    f[f.t++] = 0;
                for (; --s &gt;= 0;) {
                    var u = c[--r] == m ? this.DM : Math.floor(c[r] * o + (c[r - 1] + q) * p);
                    if ((c[r] += f.am(0, u, c, s, 0, j)) &lt; u)
                        for (f.dlShiftTo(s, t),
                        c.subTo(t, c) ; c[r] &lt; --u;)
                            c.subTo(t, c)
                }
                null != b &amp;&amp; (c.drShiftTo(j, b),
                g != h &amp;&amp; k.ZERO.subTo(b, b)),
                c.t = j,
                c.clamp(),
                i &gt; 0 &amp;&amp; c.rShiftTo(i, c),
                0 &gt; g &amp;&amp; k.ZERO.subTo(c, c)
            }
        }
    }
    function K(a) {
        var b = l();
        return this.abs().divRemTo(a, null, b),
        this.s &lt; 0 &amp;&amp; b.compareTo(k.ZERO) &gt; 0 &amp;&amp; a.subTo(b, b),
        b
    }
    function L(a) {
        this.m = a
    }
    function M(a) {
        return a.s &lt; 0 || a.compareTo(this.m) &gt;= 0 ? a.mod(this.m) : a
    }
    function N(a) {
        return a
    }
    function O(a) {
        a.divRemTo(this.m, null, a)
    }
    function P(a, b, c) {
        a.multiplyTo(b, c),
        this.reduce(c)
    }
    function Q(a, b) {
        a.squareTo(b),
        this.reduce(b)
    }
    function R() {
        if (this.t &lt; 1)
            return 0;
        var a = this[0];
        if (0 == (1 &amp; a))
            return 0;
        var b = 3 &amp; a;
        return b = b * (2 - (15 &amp; a) * b) &amp; 15,
        b = b * (2 - (255 &amp; a) * b) &amp; 255,
        b = b * (2 - ((65535 &amp; a) * b &amp; 65535)) &amp; 65535,
        b = b * (2 - a * b % this.DV) % this.DV,
        b &gt; 0 ? this.DV - b : -b
    }
    function S(a) {
        this.m = a,
        this.mp = a.invDigit(),
        this.mpl = 32767 &amp; this.mp,
        this.mph = this.mp &gt;&gt; 15,
        this.um = (1 &lt;&lt; a.DB - 15) - 1,
        this.mt2 = 2 * a.t
    }
    function T(a) {
        var b = l();
        return a.abs().dlShiftTo(this.m.t, b),
        b.divRemTo(this.m, null, b),
        a.s &lt; 0 &amp;&amp; b.compareTo(k.ZERO) &gt; 0 &amp;&amp; this.m.subTo(b, b),
        b
    }
    function U(a) {
        var b = l();
        return a.copyTo(b),
        this.reduce(b),
        b
    }
    function V(a) {
        for (; a.t &lt;= this.mt2;)
            a[a.t++] = 0;
        for (var b = 0; b &lt; this.m.t; ++b) {
            var c = 32767 &amp; a[b]
              , d = c * this.mpl + ((c * this.mph + (a[b] &gt;&gt; 15) * this.mpl &amp; this.um) &lt;&lt; 15) &amp; a.DM;
            for (c = b + this.m.t,
            a[c] += this.m.am(0, d, a, b, 0, this.m.t) ; a[c] &gt;= a.DV;)
                a[c] -= a.DV,
                a[++c]++
        }
        a.clamp(),
        a.drShiftTo(this.m.t, a),
        a.compareTo(this.m) &gt;= 0 &amp;&amp; a.subTo(this.m, a)
    }
    function W(a, b) {
        a.squareTo(b),
        this.reduce(b)
    }
    function X(a, b, c) {
        a.multiplyTo(b, c),
        this.reduce(c)
    }
    function Y() {
        return 0 == (this.t &gt; 0 ? 1 &amp; this[0] : this.s)
    }
    function Z(a, b) {
        if (a &gt; 4294967295 || 1 &gt; a)
            return k.ONE;
        var c = l()
          , d = l()
          , e = b.convert(this)
          , f = A(a) - 1;
        for (e.copyTo(c) ; --f &gt;= 0;)
            if (b.sqrTo(c, d),
            (a &amp; 1 &lt;&lt; f) &gt; 0)
                b.mulTo(d, e, c);
            else {
                var g = c;
                c = d,
                d = g
            }
        return b.revert(c)
    }
    function $(a, b) {
        var c;
        return c = 256 &gt; a || b.isEven() ? new L(b) : new S(b),
        this.exp(a, c)
    }
    function _() {
        this.i = 0,
        this.j = 0,
        this.S = new Array
    }
    function aa(a) {
        var b, c, d;
        for (b = 0; 256 &gt; b; ++b)
            this.S[b] = b;
        for (c = 0,
        b = 0; 256 &gt; b; ++b)
            c = c + this.S[b] + a[b % a.length] &amp; 255,
            d = this.S[b],
            this.S[b] = this.S[c],
            this.S[c] = d;
        this.i = 0,
        this.j = 0
    }
    function ba() {
        var a;
        return this.i = this.i + 1 &amp; 255,
        this.j = this.j + this.S[this.i] &amp; 255,
        a = this.S[this.i],
        this.S[this.i] = this.S[this.j],
        this.S[this.j] = a,
        this.S[a + this.S[this.i] &amp; 255]
    }
    function ca() {
        return new _
    }
    function da(a) {
        eb[fb++] ^= 255 &amp; a,
        eb[fb++] ^= a &gt;&gt; 8 &amp; 255,
        eb[fb++] ^= a &gt;&gt; 16 &amp; 255,
        eb[fb++] ^= a &gt;&gt; 24 &amp; 255,
        fb &gt;= gb &amp;&amp; (fb -= gb)
    }
    function ea() {
        da((new Date).getTime())
    }
    function fa() {
        if (null == db) {
            for (ea(),
            db = ca(),
            db.init(eb),
            fb = 0; fb &lt; eb.length; ++fb)
                eb[fb] = 0;
            fb = 0
        }
        return db.next()
    }
    function ga(a) {
        var b;
        for (b = 0; b &lt; a.length; ++b)
            a[b] = fa()
    }
    function ha() { }
    function ia(a, b) {
        return new k(a, b)
    }
    function ja(a, b) {
        if (b &lt; a.length + 11)
            return alert("Message too long for RSA"),
            null;
        for (var c = new Array, d = a.length - 1; d &gt;= 0 &amp;&amp; b &gt; 0;) {
            var e = a.charCodeAt(d--);
            128 &gt; e ? c[--b] = e : e &gt; 127 &amp;&amp; 2048 &gt; e ? (c[--b] = 63 &amp; e | 128,
            c[--b] = e &gt;&gt; 6 | 192) : (c[--b] = 63 &amp; e | 128,
            c[--b] = e &gt;&gt; 6 &amp; 63 | 128,
            c[--b] = e &gt;&gt; 12 | 224)
        }
        c[--b] = 0;
        for (var f = new ha, g = new Array; b &gt; 2;) {
            for (g[0] = 0; 0 == g[0];)
                f.nextBytes(g);
            c[--b] = g[0]
        }
        return c[--b] = 2,
        c[--b] = 0,
        new k(c)
    }
    function ka() {
        this.n = null,
        this.e = 0,
        this.d = null,
        this.p = null,
        this.q = null,
        this.dmp1 = null,
        this.dmq1 = null,
        this.coeff = null
    }
    function la(a, b) {
        null != a &amp;&amp; null != b &amp;&amp; a.length &gt; 0 &amp;&amp; b.length &gt; 0 ? (this.n = ia(a, 16),
        this.e = parseInt(b, 16)) : alert("Invalid RSA public key")
    }
    function ma(a) {
        return a.modPowInt(this.e, this.n)
    }
    function na(a) {
        var b = ja(a, this.n.bitLength() + 7 &gt;&gt; 3);
        if (null == b)
            return null;
        var c = this.doPublic(b);
        if (null == c)
            return null;
        var d = c.toString(16);
        return 0 == (1 &amp; d.length) ? d : "0" + d
    }
    function oa(a) {
        var b = a.split("#");
        if (3 != b.length)
            throw new Error("Malformed public key");
        lb = {
            keySeqNo: b[0],
            exponent: b[1],
            modulus: b[2]
        }
    }
    function pa(a, b) {
        return a.querySelector('[data-worldpay="' + b + '"]')
    }
    function qa(a, b) {
        var c, d;
        if ("object" == typeof a ? (c = a,
        d = b) : (c = pa(document, "payment-form"),
        d = a),
        null === c)
            throw new Error("Payment form was not supplied, and could not be found in the DOM. Did you forget to add 'data-worldpay=\"payment-form\"' to your form?");
        c.onsubmit = function () {
            return ra(c, d)
        }
    }
    function ra(a, b) {
        var c = {};
        for (var d in kb) {
            var e = pa(a, kb[d]);
            e ? c[d] = e.value : c[d] = ""
        }
        var f = sa(c, b)
          , g = pa(a, "encrypted-data");
        if (f)
            if (null !== g)
                g.value = f;
            else {
                var h = document.createElement("input");
                h.type = "hidden",
                h.setAttribute("data-worldpay", "encrypted-data"),
                h.name = "encryptedData",
                h.value = f,
                a.appendChild(h)
            }
        return null !== f
    }
    function sa(a, b) {
        var c = za(a);
        if (c.length &gt; 0)
            return b &amp;&amp; "function" == typeof b &amp;&amp; b(c),
            null;
        var d = JSON.stringify(a);
        return va(d)
    }
    function ta(a) {
        var b = Oa.codec.utf8String.toBits(a);
        return Oa.codec.base64url.fromBits(b)
    }
    function ua(a) {
        var b = Oa.codec.hex.toBits(a);
        return Oa.codec.base64url.fromBits(b)
    }
    function va(a, b, x) {

        oa(x);

        var c = ta(b)
          , d = ya(a, c, 256)
          , e = xa(d.symmetricKeyBytes)
          , f = ua(e)
          , g = c + "." + f + "." + d.ivBase64 + "." + d.encryptedDataBase64 + "." + d.tagBase64;
        return g
    }
    function wa(a) {
        for (var b = a.length / 2, c = new Array(b), d = 0; b &gt; d; d++)
            c[d] = parseInt(a.substring(2 * d, 2 * (d + 1)), 16);
        return c
    }
    function xa(a) {
        var b = new ka;
        return b.setPublic(lb.modulus, lb.exponent),
        b.encrypt(a)
    }
    function ya(a, b, c) {
        var d = Oa.random.randomWords(c / 32, 0)
          , e = Oa.codec.utf8String.toBits(a)
          , f = Oa.random.randomWords(3, 0)
          , g = Oa.codec.utf8String.toBits(b)
          , h = 128
          , i = new Oa.cipher.aes(d)
          , j = Oa.mode.gcm.encrypt(i, e, f, g, h)
          , k = Oa.bitArray.bitLength(j)
          , l = Oa.bitArray.bitSlice(j, 0, k - h)
          , m = Oa.bitArray.bitSlice(j, k - h, k)
          , n = Oa.codec.hex.fromBits(d)
          , o = wa(n)
          , p = Oa.codec.base64url.fromBits(l)
          , q = Oa.codec.base64url.fromBits(m)
          , r = Oa.codec.base64url.fromBits(f)
          , s = {
              encryptedDataBase64: p,
              symmetricKeyBytes: o,
              tagBase64: q,
              ivBase64: r
          };
        return s
    }
    function za(a) {
        var b = []
          , c = a.cardNumber
          , d = a.cvc
          , e = a.expiryMonth
          , f = a.expiryYear
          , g = a.cardHolderName;
        Ia(Ga(c), b),
        Ia(Fa(d), b),
        Ia(Ea(g), b);
        var h = Ia(Aa(e), b)
          , i = Ia(Ba(f), b);
        return h &amp;&amp; i &amp;&amp; Ia(Ca(e, f), b),
        b
    }
    function Aa(a) {
        return Ka(a) ? 301 : Ja(a, "^[0-9]{2}$") ? 0 &gt;= a || a &gt; 12 ? 303 : 0 : 302
    }
    function Ba(a) {
        return Ka(a) ? 304 : Ja(a, "^[0-9]{4}$") ? 0 : 305
    }
    function Ca(a, b) {
        return Da(a, b) ? 0 : 306
    }
    function Da(a, b) {
        var c = new Date
          , d = c.getMonth() + 1
          , e = c.getFullYear();
        return b &gt; e || b == e &amp;&amp; a &gt;= d
    }
    function Ea(a) {
        return Ka(a) ? 401 : Ja(a, "^.{1,30}$") ? 0 : 402
    }
    function Fa(a) {
        return Ja(a, "^[0-9]{3,4}$") || Ka(a) ? 0 : 201
    }
    function Ga(a) {
        return Ka(a) ? 101 : Ja(a, "^[0-9]{12,20}$") ? Ha(a) ? 0 : 103 : 102
    }
    function Ha(a) {
        var b = 0
          , c = 0
          , d = !1;
        a = a.replace(/\D/g, "");
        for (var e = a.length - 1; e &gt;= 0; e--) {
            var f = a.charAt(e);
            c = parseInt(f, 10),
            d &amp;&amp; (c *= 2) &gt; 9 &amp;&amp; (c -= 9),
            b += c,
            d = !d
        }
        return b % 10 === 0
    }
    function Ia(a, b) {
        return 0 !== a ? (b.push(a),
        !1) : !0
    }
    function Ja(a, b) {
        var c = new RegExp(b);
        return c.test(a)
    }
    function Ka(a) {
        return "" === a || !/[^\s]/.test(a)
    }
    var La, Ma = void 0, Na = !1, Oa = {
        cipher: {},
        hash: {},
        keyexchange: {},
        mode: {},
        misc: {},
        codec: {},
        exception: {
            corrupt: function (a) {
                this.toString = function () {
                    return "CORRUPT: " + this.message
                }
                ,
                this.message = a
            },
            invalid: function (a) {
                this.toString = function () {
                    return "INVALID: " + this.message
                }
                ,
                this.message = a
            },
            bug: function (a) {
                this.toString = function () {
                    return "BUG: " + this.message
                }
                ,
                this.message = a
            },
            notReady: function (a) {
                this.toString = function () {
                    return "NOT READY: " + this.message
                }
                ,
                this.message = a
            }
        }
    };
    "undefined" != typeof module &amp;&amp; module.exports &amp;&amp; (module.exports = Oa),
    "function" == typeof La &amp;&amp; La([], function () {
        return Oa
    }),
    Oa.cipher.aes = function (a) {
        this.k[0][0][0] || this.D();
        var b, d, e, f, g = this.k[0][4], h = this.k[1];
        b = a.length;
        var i = 1;
        for (4 !== b &amp;&amp; 6 !== b &amp;&amp; 8 !== b &amp;&amp; c(new Oa.exception.invalid("invalid aes key size")),
        this.b = [e = a.slice(0), f = []],
        a = b; 4 * b + 28 &gt; a; a++)
            d = e[a - 1],
            (0 === a % b || 8 === b &amp;&amp; 4 === a % b) &amp;&amp; (d = g[d &gt;&gt;&gt; 24] &lt;&lt; 24 ^ g[d &gt;&gt; 16 &amp; 255] &lt;&lt; 16 ^ g[d &gt;&gt; 8 &amp; 255] &lt;&lt; 8 ^ g[255 &amp; d],
            0 === a % b &amp;&amp; (d = d &lt;&lt; 8 ^ d &gt;&gt;&gt; 24 ^ i &lt;&lt; 24,
            i = i &lt;&lt; 1 ^ 283 * (i &gt;&gt; 7))),
            e[a] = e[a - b] ^ d;
        for (b = 0; a; b++,
        a--)
            d = e[3 &amp; b ? a : a - 4],
            f[b] = 4 &gt;= a || 4 &gt; b ? d : h[0][g[d &gt;&gt;&gt; 24]] ^ h[1][g[d &gt;&gt; 16 &amp; 255]] ^ h[2][g[d &gt;&gt; 8 &amp; 255]] ^ h[3][g[255 &amp; d]]
    }
    ,
    Oa.cipher.aes.prototype = {
        encrypt: function (a) {
            return d(this, a, 0)
        },
        decrypt: function (a) {
            return d(this, a, 1)
        },
        k: [[[], [], [], [], []], [[], [], [], [], []]],
        D: function () {
            var a, b, c, d, e, f, g, h = this.k[0], i = this.k[1], j = h[4], k = i[4], l = [], m = [];
            for (a = 0; 256 &gt; a; a++)
                m[(l[a] = a &lt;&lt; 1 ^ 283 * (a &gt;&gt; 7)) ^ a] = a;
            for (b = c = 0; !j[b]; b ^= d || 1,
            c = m[c] || 1)
                for (f = c ^ c &lt;&lt; 1 ^ c &lt;&lt; 2 ^ c &lt;&lt; 3 ^ c &lt;&lt; 4,
                f = f &gt;&gt; 8 ^ 255 &amp; f ^ 99,
                j[b] = f,
                k[f] = b,
                e = l[a = l[d = l[b]]],
                g = 16843009 * e ^ 65537 * a ^ 257 * d ^ 16843008 * b,
                e = 257 * l[f] ^ 16843008 * f,
                a = 0; 4 &gt; a; a++)
                    h[a][b] = e = e &lt;&lt; 24 ^ e &gt;&gt;&gt; 8,
                    i[a][f] = g = g &lt;&lt; 24 ^ g &gt;&gt;&gt; 8;
            for (a = 0; 5 &gt; a; a++)
                h[a] = h[a].slice(0),
                i[a] = i[a].slice(0)
        }
    },
    Oa.bitArray = {
        bitSlice: function (a, b, c) {
            return a = Oa.bitArray.P(a.slice(b / 32), 32 - (31 &amp; b)).slice(1),
            c === Ma ? a : Oa.bitArray.clamp(a, c - b)
        },
        extract: function (a, b, c) {
            var d = Math.floor(-b - c &amp; 31);
            return (-32 &amp; (b + c - 1 ^ b) ? a[b / 32 | 0] &lt;&lt; 32 - d ^ a[b / 32 + 1 | 0] &gt;&gt;&gt; d : a[b / 32 | 0] &gt;&gt;&gt; d) &amp; (1 &lt;&lt; c) - 1
        },
        concat: function (a, b) {
            if (0 === a.length || 0 === b.length)
                return a.concat(b);
            var c = a[a.length - 1]
              , d = Oa.bitArray.getPartial(c);
            return 32 === d ? a.concat(b) : Oa.bitArray.P(b, d, 0 | c, a.slice(0, a.length - 1))
        },
        bitLength: function (a) {
            var b = a.length;
            return 0 === b ? 0 : 32 * (b - 1) + Oa.bitArray.getPartial(a[b - 1])
        },
        clamp: function (a, b) {
            if (32 * a.length &lt; b)
                return a;
            a = a.slice(0, Math.ceil(b / 32));
            var c = a.length;
            return b &amp;= 31,
            c &gt; 0 &amp;&amp; b &amp;&amp; (a[c - 1] = Oa.bitArray.partial(b, a[c - 1] &amp; 2147483648 &gt;&gt; b - 1, 1)),
            a
        },
        partial: function (a, b, c) {
            return 32 === a ? b : (c ? 0 | b : b &lt;&lt; 32 - a) + 1099511627776 * a
        },
        getPartial: function (a) {
            return Math.round(a / 1099511627776) || 32
        },
        equal: function (a, b) {
            if (Oa.bitArray.bitLength(a) !== Oa.bitArray.bitLength(b))
                return Na;
            var c, d = 0;
            for (c = 0; c &lt; a.length; c++)
                d |= a[c] ^ b[c];
            return 0 === d
        },
        P: function (a, b, c, d) {
            var e;
            for (e = 0,
            d === Ma &amp;&amp; (d = []) ; b &gt;= 32; b -= 32)
                d.push(c),
                c = 0;
            if (0 === b)
                return d.concat(a);
            for (e = 0; e &lt; a.length; e++)
                d.push(c | a[e] &gt;&gt;&gt; b),
                c = a[e] &lt;&lt; 32 - b;
            return e = a.length ? a[a.length - 1] : 0,
            a = Oa.bitArray.getPartial(e),
            d.push(Oa.bitArray.partial(b + a &amp; 31, b + a &gt; 32 ? c : d.pop(), 1)),
            d
        },
        l: function (a, b) {
            return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
        },
        byteswapM: function (a) {
            var b, c;
            for (b = 0; b &lt; a.length; ++b)
                c = a[b],
                a[b] = c &gt;&gt;&gt; 24 | c &gt;&gt;&gt; 8 &amp; 65280 | (65280 &amp; c) &lt;&lt; 8 | c &lt;&lt; 24;
            return a
        }
    },
    Oa.codec.utf8String = {
        fromBits: function (a) {
            var b, c, d = "", e = Oa.bitArray.bitLength(a);
            for (b = 0; e / 8 &gt; b; b++)
                0 === (3 &amp; b) &amp;&amp; (c = a[b / 4]),
                d += String.fromCharCode(c &gt;&gt;&gt; 24),
                c &lt;&lt;= 8;
            return decodeURIComponent(escape(d))
        },
        toBits: function (a) {
            a = unescape(encodeURIComponent(a));
            var b, c = [], d = 0;
            for (b = 0; b &lt; a.length; b++)
                d = d &lt;&lt; 8 | a.charCodeAt(b),
                3 === (3 &amp; b) &amp;&amp; (c.push(d),
                d = 0);
            return 3 &amp; b &amp;&amp; c.push(Oa.bitArray.partial(8 * (3 &amp; b), d)),
            c
        }
    },
    Oa.codec.hex = {
        fromBits: function (a) {
            var b, c = "";
            for (b = 0; b &lt; a.length; b++)
                c += ((0 | a[b]) + 0xf00000000000).toString(16).substr(4);
            return c.substr(0, Oa.bitArray.bitLength(a) / 4)
        },
        toBits: function (a) {
            var b, c, d = [];
            for (a = a.replace(/\s|0x/g, ""),
            c = a.length,
            a += "00000000",
            b = 0; b &lt; a.length; b += 8)
                d.push(0 ^ parseInt(a.substr(b, 8), 16));
            return Oa.bitArray.clamp(d, 4 * c)
        }
    },
    Oa.codec.base64 = {
        J: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        fromBits: function (a, b, c) {
            var d = ""
              , e = 0
              , f = Oa.codec.base64.J
              , g = 0
              , h = Oa.bitArray.bitLength(a);
            for (c &amp;&amp; (f = f.substr(0, 62) + "-_"),
            c = 0; 6 * d.length &lt; h;)
                d += f.charAt((g ^ a[c] &gt;&gt;&gt; e) &gt;&gt;&gt; 26),
                6 &gt; e ? (g = a[c] &lt;&lt; 6 - e,
                e += 26,
                c++) : (g &lt;&lt;= 6,
                e -= 6);
            for (; 3 &amp; d.length &amp;&amp; !b;)
                d += "=";
            return d
        },
        toBits: function (a, b) {
            a = a.replace(/\s|=/g, "");
            var d, e, f = [], g = 0, h = Oa.codec.base64.J, i = 0;
            for (b &amp;&amp; (h = h.substr(0, 62) + "-_"),
            d = 0; d &lt; a.length; d++)
                e = h.indexOf(a.charAt(d)),
                0 &gt; e &amp;&amp; c(new Oa.exception.invalid("this isn't base64!")),
                g &gt; 26 ? (g -= 26,
                f.push(i ^ e &gt;&gt;&gt; g),
                i = e &lt;&lt; 32 - g) : (g += 6,
                i ^= e &lt;&lt; 32 - g);
            return 56 &amp; g &amp;&amp; f.push(Oa.bitArray.partial(56 &amp; g, i, 1)),
            f
        }
    },
    Oa.codec.base64url = {
        fromBits: function (a) {
            return Oa.codec.base64.fromBits(a, 1, 1)
        },
        toBits: function (a) {
            return Oa.codec.base64.toBits(a, 1)
        }
    },
    Oa.hash.sha256 = function (a) {
        this.b[0] || this.D(),
        a ? (this.r = a.r.slice(0),
        this.o = a.o.slice(0),
        this.h = a.h) : this.reset()
    }
    ,
    Oa.hash.sha256.hash = function (a) {
        return (new Oa.hash.sha256).update(a).finalize()
    }
    ,
    Oa.hash.sha256.prototype = {
        blockSize: 512,
        reset: function () {
            return this.r = this.N.slice(0),
            this.o = [],
            this.h = 0,
            this
        },
        update: function (a) {
            "string" == typeof a &amp;&amp; (a = Oa.codec.utf8String.toBits(a));
            var b, c = this.o = Oa.bitArray.concat(this.o, a);
            for (b = this.h,
            a = this.h = b + Oa.bitArray.bitLength(a),
            b = 512 + b &amp; -512; a &gt;= b; b += 512)
                e(this, c.splice(0, 16));
            return this
        },
        finalize: function () {
            var a, b = this.o, c = this.r, b = Oa.bitArray.concat(b, [Oa.bitArray.partial(1, 1)]);
            for (a = b.length + 2; 15 &amp; a; a++)
                b.push(0);
            for (b.push(Math.floor(this.h / 4294967296)),
            b.push(0 | this.h) ; b.length;)
                e(this, b.splice(0, 16));
            return this.reset(),
            c
        },
        N: [],
        b: [],
        D: function () {
            function a(a) {
                return 4294967296 * (a - Math.floor(a)) | 0
            }
            var b, c = 0, d = 2;
            a: for (; 64 &gt; c; d++) {
                for (b = 2; d &gt;= b * b; b++)
                    if (0 === d % b)
                        continue a;
                8 &gt; c &amp;&amp; (this.N[c] = a(Math.pow(d, .5))),
                this.b[c] = a(Math.pow(d, 1 / 3)),
                c++
            }
        }
    },
    Oa.mode.ccm = {
        name: "ccm",
        encrypt: function (a, b, d, e, f) {
            var g, h = b.slice(0), i = Oa.bitArray, j = i.bitLength(d) / 8, k = i.bitLength(h) / 8;
            for (f = f || 64,
            e = e || [],
            7 &gt; j &amp;&amp; c(new Oa.exception.invalid("ccm: iv must be at least 7 bytes")),
            g = 2; 4 &gt; g &amp;&amp; k &gt;&gt;&gt; 8 * g; g++)
                ;
            return 15 - j &gt; g &amp;&amp; (g = 15 - j),
            d = i.clamp(d, 8 * (15 - g)),
            b = Oa.mode.ccm.L(a, b, d, e, f, g),
            h = Oa.mode.ccm.p(a, h, d, b, f, g),
            i.concat(h.data, h.tag)
        },
        decrypt: function (a, b, d, e, f) {
            f = f || 64,
            e = e || [];
            var g = Oa.bitArray
              , h = g.bitLength(d) / 8
              , i = g.bitLength(b)
              , j = g.clamp(b, i - f)
              , k = g.bitSlice(b, i - f)
              , i = (i - f) / 8;
            for (7 &gt; h &amp;&amp; c(new Oa.exception.invalid("ccm: iv must be at least 7 bytes")),
            b = 2; 4 &gt; b &amp;&amp; i &gt;&gt;&gt; 8 * b; b++)
                ;
            return 15 - h &gt; b &amp;&amp; (b = 15 - h),
            d = g.clamp(d, 8 * (15 - b)),
            j = Oa.mode.ccm.p(a, j, d, k, f, b),
            a = Oa.mode.ccm.L(a, j.data, d, e, f, b),
            g.equal(j.tag, a) || c(new Oa.exception.corrupt("ccm: tag doesn't match")),
            j.data
        },
        L: function (a, b, d, e, f, g) {
            var h = []
              , i = Oa.bitArray
              , j = i.l;
            if (f /= 8,
            (f % 2 || 4 &gt; f || f &gt; 16) &amp;&amp; c(new Oa.exception.invalid("ccm: invalid tag length")),
            (4294967295 &lt; e.length || 4294967295 &lt; b.length) &amp;&amp; c(new Oa.exception.bug("ccm: can't deal with 4GiB or more data")),
            g = [i.partial(8, (e.length ? 64 : 0) | f - 2 &lt;&lt; 2 | g - 1)],
            g = i.concat(g, d),
            g[3] |= i.bitLength(b) / 8,
            g = a.encrypt(g),
            e.length)
                for (d = i.bitLength(e) / 8,
                65279 &gt;= d ? h = [i.partial(16, d)] : 4294967295 &gt;= d &amp;&amp; (h = i.concat([i.partial(16, 65534)], [d])),
                h = i.concat(h, e),
                e = 0; e &lt; h.length; e += 4)
                    g = a.encrypt(j(g, h.slice(e, e + 4).concat([0, 0, 0])));
            for (e = 0; e &lt; b.length; e += 4)
                g = a.encrypt(j(g, b.slice(e, e + 4).concat([0, 0, 0])));
            return i.clamp(g, 8 * f)
        },
        p: function (a, b, c, d, e, f) {
            var g, h = Oa.bitArray;
            g = h.l;
            var i = b.length
              , j = h.bitLength(b);
            if (c = h.concat([h.partial(8, f - 1)], c).concat([0, 0, 0]).slice(0, 4),
            d = h.bitSlice(g(d, a.encrypt(c)), 0, e),
            !i)
                return {
                    tag: d,
                    data: []
                };
            for (g = 0; i &gt; g; g += 4)
                c[3]++,
                e = a.encrypt(c),
                b[g] ^= e[0],
                b[g + 1] ^= e[1],
                b[g + 2] ^= e[2],
                b[g + 3] ^= e[3];
            return {
                tag: d,
                data: h.clamp(b, j)
            }
        }
    },
    Oa.mode.ocb2 = {
        name: "ocb2",
        encrypt: function (a, b, d, e, f, g) {
            128 !== Oa.bitArray.bitLength(d) &amp;&amp; c(new Oa.exception.invalid("ocb iv must be 128 bits"));
            var h, i = Oa.mode.ocb2.H, j = Oa.bitArray, k = j.l, l = [0, 0, 0, 0];
            d = i(a.encrypt(d));
            var m, n = [];
            for (e = e || [],
            f = f || 64,
            h = 0; h + 4 &lt; b.length; h += 4)
                m = b.slice(h, h + 4),
                l = k(l, m),
                n = n.concat(k(d, a.encrypt(k(d, m)))),
                d = i(d);
            return m = b.slice(h),
            b = j.bitLength(m),
            h = a.encrypt(k(d, [0, 0, 0, b])),
            m = j.clamp(k(m.concat([0, 0, 0]), h), b),
            l = k(l, k(m.concat([0, 0, 0]), h)),
            l = a.encrypt(k(l, k(d, i(d)))),
            e.length &amp;&amp; (l = k(l, g ? e : Oa.mode.ocb2.pmac(a, e))),
            n.concat(j.concat(m, j.clamp(l, f)))
        },
        decrypt: function (a, b, d, e, f, g) {
            128 !== Oa.bitArray.bitLength(d) &amp;&amp; c(new Oa.exception.invalid("ocb iv must be 128 bits")),
            f = f || 64;
            var h, i, j = Oa.mode.ocb2.H, k = Oa.bitArray, l = k.l, m = [0, 0, 0, 0], n = j(a.encrypt(d)), o = Oa.bitArray.bitLength(b) - f, p = [];
            for (e = e || [],
            d = 0; o / 32 &gt; d + 4; d += 4)
                h = l(n, a.decrypt(l(n, b.slice(d, d + 4)))),
                m = l(m, h),
                p = p.concat(h),
                n = j(n);
            return i = o - 32 * d,
            h = a.encrypt(l(n, [0, 0, 0, i])),
            h = l(h, k.clamp(b.slice(d), i).concat([0, 0, 0])),
            m = l(m, h),
            m = a.encrypt(l(m, l(n, j(n)))),
            e.length &amp;&amp; (m = l(m, g ? e : Oa.mode.ocb2.pmac(a, e))),
            k.equal(k.clamp(m, f), k.bitSlice(b, o)) || c(new Oa.exception.corrupt("ocb: tag doesn't match")),
            p.concat(k.clamp(h, i))
        },
        pmac: function (a, b) {
            var c, d = Oa.mode.ocb2.H, e = Oa.bitArray, f = e.l, g = [0, 0, 0, 0], h = a.encrypt([0, 0, 0, 0]), h = f(h, d(d(h)));
            for (c = 0; c + 4 &lt; b.length; c += 4)
                h = d(h),
                g = f(g, a.encrypt(f(h, b.slice(c, c + 4))));
            return c = b.slice(c),
            128 &gt; e.bitLength(c) &amp;&amp; (h = f(h, d(h)),
            c = e.concat(c, [-2147483648, 0, 0, 0])),
            g = f(g, c),
            a.encrypt(f(d(f(h, d(h))), g))
        },
        H: function (a) {
            return [a[0] &lt;&lt; 1 ^ a[1] &gt;&gt;&gt; 31, a[1] &lt;&lt; 1 ^ a[2] &gt;&gt;&gt; 31, a[2] &lt;&lt; 1 ^ a[3] &gt;&gt;&gt; 31, a[3] &lt;&lt; 1 ^ 135 * (a[0] &gt;&gt;&gt; 31)]
        }
    },
    Oa.mode.gcm = {
        name: "gcm",
        encrypt: function (a, b, c, d, e) {
            var f = b.slice(0);
            return b = Oa.bitArray,
            d = d || [],
            a = Oa.mode.gcm.p(!0, a, f, d, c, e || 128),
            b.concat(a.data, a.tag)
        },
        decrypt: function (a, b, d, e, f) {
            var g = b.slice(0)
              , h = Oa.bitArray
              , i = h.bitLength(g);
            return f = f || 128,
            e = e || [],
            i &gt;= f ? (b = h.bitSlice(g, i - f),
            g = h.bitSlice(g, 0, i - f)) : (b = g,
            g = []),
            a = Oa.mode.gcm.p(Na, a, g, e, d, f),
            h.equal(a.tag, b) || c(new Oa.exception.corrupt("gcm: tag doesn't match")),
            a.data
        },
        Z: function (a, b) {
            var c, d, e, f, g, h = Oa.bitArray.l;
            for (e = [0, 0, 0, 0],
            f = b.slice(0),
            c = 0; 128 &gt; c; c++) {
                for ((d = 0 !== (a[Math.floor(c / 32)] &amp; 1 &lt;&lt; 31 - c % 32)) &amp;&amp; (e = h(e, f)),
                g = 0 !== (1 &amp; f[3]),
                d = 3; d &gt; 0; d--)
                    f[d] = f[d] &gt;&gt;&gt; 1 | (1 &amp; f[d - 1]) &lt;&lt; 31;
                f[0] &gt;&gt;&gt;= 1,
                g &amp;&amp; (f[0] ^= -520093696)
            }
            return e
        },
        g: function (a, b, c) {
            var d, e = c.length;
            for (b = b.slice(0),
            d = 0; e &gt; d; d += 4)
                b[0] ^= 4294967295 &amp; c[d],
                b[1] ^= 4294967295 &amp; c[d + 1],
                b[2] ^= 4294967295 &amp; c[d + 2],
                b[3] ^= 4294967295 &amp; c[d + 3],
                b = Oa.mode.gcm.Z(b, a);
            return b
        },
        p: function (a, b, c, d, e, f) {
            var g, h, i, j, k, l, m, n, o = Oa.bitArray;
            for (l = c.length,
            m = o.bitLength(c),
            n = o.bitLength(d),
            h = o.bitLength(e),
            g = b.encrypt([0, 0, 0, 0]),
            96 === h ? (e = e.slice(0),
            e = o.concat(e, [1])) : (e = Oa.mode.gcm.g(g, [0, 0, 0, 0], e),
            e = Oa.mode.gcm.g(g, e, [0, 0, Math.floor(h / 4294967296), 4294967295 &amp; h])),
            h = Oa.mode.gcm.g(g, [0, 0, 0, 0], d),
            k = e.slice(0),
            d = h.slice(0),
            a || (d = Oa.mode.gcm.g(g, h, c)),
            j = 0; l &gt; j; j += 4)
                k[3]++,
                i = b.encrypt(k),
                c[j] ^= i[0],
                c[j + 1] ^= i[1],
                c[j + 2] ^= i[2],
                c[j + 3] ^= i[3];
            return c = o.clamp(c, m),
            a &amp;&amp; (d = Oa.mode.gcm.g(g, h, c)),
            a = [Math.floor(n / 4294967296), 4294967295 &amp; n, Math.floor(m / 4294967296), 4294967295 &amp; m],
            d = Oa.mode.gcm.g(g, d, a),
            i = b.encrypt(e),
            d[0] ^= i[0],
            d[1] ^= i[1],
            d[2] ^= i[2],
            d[3] ^= i[3],
            {
                tag: o.bitSlice(d, 0, f),
                data: c
            }
        }
    },
    Oa.misc.hmac = function (a, b) {
        this.M = b = b || Oa.hash.sha256;
        var c, d = [[], []], e = b.prototype.blockSize / 32;
        for (this.n = [new b, new b],
        a.length &gt; e &amp;&amp; (a = b.hash(a)),
        c = 0; e &gt; c; c++)
            d[0][c] = 909522486 ^ a[c],
            d[1][c] = 1549556828 ^ a[c];
        this.n[0].update(d[0]),
        this.n[1].update(d[1]),
        this.G = new b(this.n[0])
    }
    ,
    Oa.misc.hmac.prototype.encrypt = Oa.misc.hmac.prototype.mac = function (a) {
        return this.Q &amp;&amp; c(new Oa.exception.invalid("encrypt on already updated hmac called!")),
        this.update(a),
        this.digest(a)
    }
    ,
    Oa.misc.hmac.prototype.reset = function () {
        this.G = new this.M(this.n[0]),
        this.Q = Na
    }
    ,
    Oa.misc.hmac.prototype.update = function (a) {
        this.Q = !0,
        this.G.update(a)
    }
    ,
    Oa.misc.hmac.prototype.digest = function () {
        var a = this.G.finalize()
          , a = new this.M(this.n[1]).update(a).finalize();
        return this.reset(),
        a
    }
    ,
    Oa.misc.pbkdf2 = function (a, b, d, e, f) {
        d = d || 1e3,
        (0 &gt; e || 0 &gt; d) &amp;&amp; c(Oa.exception.invalid("invalid params to pbkdf2")),
        "string" == typeof a &amp;&amp; (a = Oa.codec.utf8String.toBits(a)),
        "string" == typeof b &amp;&amp; (b = Oa.codec.utf8String.toBits(b)),
        f = f || Oa.misc.hmac,
        a = new f(a);
        var g, h, i, j, k = [], l = Oa.bitArray;
        for (j = 1; 32 * k.length &lt; (e || 1) ; j++) {
            for (f = g = a.encrypt(l.concat(b, [j])),
            h = 1; d &gt; h; h++)
                for (g = a.encrypt(g),
                i = 0; i &lt; g.length; i++)
                    f[i] ^= g[i];
            k = k.concat(f)
        }
        return e &amp;&amp; (k = l.clamp(k, e)),
        k
    }
    ,
    Oa.prng = function (a) {
        this.c = [new Oa.hash.sha256],
        this.i = [0],
        this.F = 0,
        this.s = {},
        this.C = 0,
        this.K = {},
        this.O = this.d = this.j = this.W = 0,
        this.b = [0, 0, 0, 0, 0, 0, 0, 0],
        this.f = [0, 0, 0, 0],
        this.A = Ma,
        this.B = a,
        this.q = Na,
        this.w = {
            progress: {},
            seeded: {}
        },
        this.m = this.V = 0,
        this.t = 1,
        this.u = 2,
        this.S = 65536,
        this.I = [0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024],
        this.T = 3e4,
        this.R = 80
    }
    ,
    Oa.prng.prototype = {
        randomWords: function (a, b) {
            var d, e = [];
            d = this.isReady(b);
            var f;
            if (d === this.m &amp;&amp; c(new Oa.exception.notReady("generator isn't seeded")),
            d &amp; this.u) {
                d = !(d &amp; this.t),
                f = [];
                var g, j = 0;
                for (this.O = f[0] = (new Date).valueOf() + this.T,
                g = 0; 16 &gt; g; g++)
                    f.push(4294967296 * Math.random() | 0);
                for (g = 0; g &lt; this.c.length &amp;&amp; (f = f.concat(this.c[g].finalize()),
                j += this.i[g],
                this.i[g] = 0,
                !(!d &amp;&amp; this.F &amp; 1 &lt;&lt; g)) ; g++)
                    ;
                for (this.F &gt;= 1 &lt;&lt; this.c.length &amp;&amp; (this.c.push(new Oa.hash.sha256),
                this.i.push(0)),
                this.d -= j,
                j &gt; this.j &amp;&amp; (this.j = j),
                this.F++,
                this.b = Oa.hash.sha256.hash(this.b.concat(f)),
                this.A = new Oa.cipher.aes(this.b),
                d = 0; 4 &gt; d &amp;&amp; (this.f[d] = this.f[d] + 1 | 0,
                !this.f[d]) ; d++)
                    ;
            }
            for (d = 0; a &gt; d; d += 4)
                0 === (d + 1) % this.S &amp;&amp; h(this),
                f = i(this),
                e.push(f[0], f[1], f[2], f[3]);
            return h(this),
            e.slice(0, a)
        },
        setDefaultParanoia: function (a, b) {
            0 === a &amp;&amp; "Setting paranoia=0 will ruin your security; use it only for testing" !== b &amp;&amp; c("Setting paranoia=0 will ruin your security; use it only for testing"),
            this.B = a
        },
        addEntropy: function (a, b, d) {
            d = d || "user";
            var e, g, h = (new Date).valueOf(), i = this.s[d], j = this.isReady(), k = 0;
            switch (e = this.K[d],
            e === Ma &amp;&amp; (e = this.K[d] = this.W++),
            i === Ma &amp;&amp; (i = this.s[d] = 0),
            this.s[d] = (this.s[d] + 1) % this.c.length,
            typeof a) {
                case "number":
                    b === Ma &amp;&amp; (b = 1),
                    this.c[i].update([e, this.C++, 1, b, h, 1, 0 | a]);
                    break;
                case "object":
                    if (d = Object.prototype.toString.call(a),
                    "[object Uint32Array]" === d) {
                        for (g = [],
                        d = 0; d &lt; a.length; d++)
                            g.push(a[d]);
                        a = g
                    } else
                        for ("[object Array]" !== d &amp;&amp; (k = 1),
                        d = 0; d &lt; a.length &amp;&amp; !k; d++)
                            "number" != typeof a[d] &amp;&amp; (k = 1);
                    if (!k) {
                        if (b === Ma)
                            for (d = b = 0; d &lt; a.length; d++)
                                for (g = a[d]; g &gt; 0;)
                                    b++,
                                    g &gt;&gt;&gt;= 1;
                        this.c[i].update([e, this.C++, 2, b, h, a.length].concat(a))
                    }
                    break;
                case "string":
                    b === Ma &amp;&amp; (b = a.length),
                    this.c[i].update([e, this.C++, 3, b, h, a.length]),
                    this.c[i].update(a);
                    break;
                default:
                    k = 1
            }
            k &amp;&amp; c(new Oa.exception.bug("random: addEntropy only supports number, array of numbers or string")),
            this.i[i] += b,
            this.d += b,
            j === this.m &amp;&amp; (this.isReady() !== this.m &amp;&amp; f("seeded", Math.max(this.j, this.d)),
            f("progress", this.getProgress()))
        },
        isReady: function (a) {
            return a = this.I[a !== Ma ? a : this.B],
            this.j &amp;&amp; this.j &gt;= a ? this.i[0] &gt; this.R &amp;&amp; (new Date).valueOf() &gt; this.O ? this.u | this.t : this.t : this.d &gt;= a ? this.u | this.m : this.m
        },
        getProgress: function (a) {
            return a = this.I[a ? a : this.B],
            this.j &gt;= a ? 1 : this.d &gt; a ? 1 : this.d / a
        },
        $: function () {
            g(1)
        },
        ba: function (a) {
            var b, c;
            try {
                b = a.x || a.clientX || a.offsetX || 0,
                c = a.y || a.clientY || a.offsetY || 0
            } catch (d) {
                c = b = 0
            }
            0 != b &amp;&amp; 0 != c &amp;&amp; Oa.random.addEntropy([b, c], 2, "mouse"),
            g(0)
        },
        da: function (a) {
            a = a.touches[0] || a.changedTouches[0],
            Oa.random.addEntropy([a.pageX || a.clientX, a.pageY || a.clientY], 1, "touch"),
            g(0)
        },
        aa: function () {
            g(2)
        },
        U: function (a) {
            if (a = a.accelerationIncludingGravity.x || a.accelerationIncludingGravity.y || a.accelerationIncludingGravity.z,
            window.orientation) {
                var b = window.orientation;
                "number" == typeof b &amp;&amp; Oa.random.addEntropy(b, 1, "accelerometer")
            }
            a &amp;&amp; Oa.random.addEntropy(a, 2, "accelerometer"),
            g(0)
        }
    },
    Oa.random = new Oa.prng(6);
    a: try {
        var Pa, Qa, Ra, Sa;
        if (Sa = "undefined" != typeof module) {
            var Ta;
            if (Ta = module.exports) {
                var Ua;
                try {
                    Ua = require("crypto")
                } catch (Va) {
                    Ua = null
                }
                Ta = (Qa = Ua) &amp;&amp; Qa.randomBytes
            }
            Sa = Ta
        }
        if (Sa)
            Pa = Qa.randomBytes(128),
            Pa = new Uint32Array(new Uint8Array(Pa).buffer),
            Oa.random.addEntropy(Pa, 1024, "crypto['randomBytes']");
        else if ("undefined" != typeof window &amp;&amp; "undefined" != typeof Uint32Array) {
            if (Ra = new Uint32Array(32),
            crypto &amp;&amp; crypto.getRandomValues)
                crypto.getRandomValues(Ra);
            else {
                if (!window.msCrypto || !window.msCrypto.getRandomValues)
                    break a;
                window.msCrypto.getRandomValues(Ra)
            }
            Oa.random.addEntropy(Ra, 1024, "crypto['getRandomValues']")
        }
    } catch (Wa) {
        "undefined" != typeof window &amp;&amp; window.console &amp;&amp; (console.log("There was an error collecting entropy from the browser:"),
        console.log(Wa))
    }
    Oa.json = {
        defaults: {
            v: 1,
            iter: 1e3,
            ks: 128,
            ts: 64,
            mode: "ccm",
            adata: "",
            cipher: "aes"
        },
        Y: function (a, b, d, e) {
            d = d || {},
            e = e || {};
            var f, g = Oa.json, h = g.e({
                iv: Oa.random.randomWords(4, 0)
            }, g.defaults);
            return g.e(h, d),
            d = h.adata,
            "string" == typeof h.salt &amp;&amp; (h.salt = Oa.codec.base64.toBits(h.salt)),
            "string" == typeof h.iv &amp;&amp; (h.iv = Oa.codec.base64.toBits(h.iv)),
            (!Oa.mode[h.mode] || !Oa.cipher[h.cipher] || "string" == typeof a &amp;&amp; 100 &gt;= h.iter || 64 !== h.ts &amp;&amp; 96 !== h.ts &amp;&amp; 128 !== h.ts || 128 !== h.ks &amp;&amp; 192 !== h.ks &amp;&amp; 256 !== h.ks || 2 &gt; h.iv.length || 4 &lt; h.iv.length) &amp;&amp; c(new Oa.exception.invalid("json encrypt: invalid parameters")),
            "string" == typeof a ? (f = Oa.misc.cachedPbkdf2(a, h),
            a = f.key.slice(0, h.ks / 32),
            h.salt = f.salt) : Oa.ecc &amp;&amp; a instanceof Oa.ecc.elGamal.publicKey &amp;&amp; (f = a.kem(),
            h.kemtag = f.tag,
            a = f.key.slice(0, h.ks / 32)),
            "string" == typeof b &amp;&amp; (b = Oa.codec.utf8String.toBits(b)),
            "string" == typeof d &amp;&amp; (h.adata = d = Oa.codec.utf8String.toBits(d)),
            f = new Oa.cipher[h.cipher](a),
            g.e(e, h),
            e.key = a,
            h.ct = Oa.mode[h.mode].encrypt(f, b, h.iv, d, h.ts),
            h
        },
        encrypt: function (a, b, c, d) {
            var e = Oa.json
              , f = e.Y.apply(e, arguments);
            return e.encode(f)
        },
        X: function (a, b, d, e) {
            d = d || {},
            e = e || {};
            var f = Oa.json;
            b = f.e(f.e(f.e({}, f.defaults), b), d, !0);
            var g, h;
            return g = b.adata,
            "string" == typeof b.salt &amp;&amp; (b.salt = Oa.codec.base64.toBits(b.salt)),
            "string" == typeof b.iv &amp;&amp; (b.iv = Oa.codec.base64.toBits(b.iv)),
            (!Oa.mode[b.mode] || !Oa.cipher[b.cipher] || "string" == typeof a &amp;&amp; 100 &gt;= b.iter || 64 !== b.ts &amp;&amp; 96 !== b.ts &amp;&amp; 128 !== b.ts || 128 !== b.ks &amp;&amp; 192 !== b.ks &amp;&amp; 256 !== b.ks || !b.iv || 2 &gt; b.iv.length || 4 &lt; b.iv.length) &amp;&amp; c(new Oa.exception.invalid("json decrypt: invalid parameters")),
            "string" == typeof a ? (h = Oa.misc.cachedPbkdf2(a, b),
            a = h.key.slice(0, b.ks / 32),
            b.salt = h.salt) : Oa.ecc &amp;&amp; a instanceof Oa.ecc.elGamal.secretKey &amp;&amp; (a = a.unkem(Oa.codec.base64.toBits(b.kemtag)).slice(0, b.ks / 32)),
            "string" == typeof g &amp;&amp; (g = Oa.codec.utf8String.toBits(g)),
            h = new Oa.cipher[b.cipher](a),
            g = Oa.mode[b.mode].decrypt(h, b.ct, b.iv, g, b.ts),
            f.e(e, b),
            e.key = a,
            1 === d.raw ? g : Oa.codec.utf8String.fromBits(g)
        },
        decrypt: function (a, b, c, d) {
            var e = Oa.json;
            return e.X(a, e.decode(b), c, d)
        },
        encode: function (a) {
            var b, d = "{", e = "";
            for (b in a)
                if (a.hasOwnProperty(b))
                    switch (b.match(/^[a-z0-9]+$/i) || c(new Oa.exception.invalid("json encode: invalid property name")),
                    d += e + '"' + b + '":',
                    e = ",",
                    typeof a[b]) {
                        case "number":
                        case "boolean":
                            d += a[b];
                            break;
                        case "string":
                            d += '"' + escape(a[b]) + '"';
                            break;
                        case "object":
                            d += '"' + Oa.codec.base64.fromBits(a[b], 0) + '"';
                            break;
                        default:
                            c(new Oa.exception.bug("json encode: unsupported type"))
                    }
            return d + "}"
        },
        decode: function (a) {
            a = a.replace(/\s/g, ""),
            a.match(/^\{.*\}$/) || c(new Oa.exception.invalid("json decode: this isn't json!")),
            a = a.replace(/^\{|\}$/g, "").split(/,/);
            var b, d, e = {};
            for (b = 0; b &lt; a.length; b++)
                (d = a[b].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i)) || c(new Oa.exception.invalid("json decode: this isn't json!")),
                d[3] ? e[d[2]] = parseInt(d[3], 10) : d[4] ? e[d[2]] = d[2].match(/^(ct|adata|salt|iv)$/) ? Oa.codec.base64.toBits(d[4]) : unescape(d[4]) : d[5] &amp;&amp; (e[d[2]] = "true" === d[5]);
            return e
        },
        e: function (a, b, d) {
            if (a === Ma &amp;&amp; (a = {}),
            b === Ma)
                return a;
            for (var e in b)
                b.hasOwnProperty(e) &amp;&amp; (d &amp;&amp; a[e] !== Ma &amp;&amp; a[e] !== b[e] &amp;&amp; c(new Oa.exception.invalid("required parameter overridden")),
                a[e] = b[e]);
            return a
        },
        fa: function (a, b) {
            var c, d = {};
            for (c in a)
                a.hasOwnProperty(c) &amp;&amp; a[c] !== b[c] &amp;&amp; (d[c] = a[c]);
            return d
        },
        ea: function (a, b) {
            var c, d = {};
            for (c = 0; c &lt; b.length; c++)
                a[b[c]] !== Ma &amp;&amp; (d[b[c]] = a[b[c]]);
            return d
        }
    },
    Oa.encrypt = Oa.json.encrypt,
    Oa.decrypt = Oa.json.decrypt,
    Oa.misc.ca = {},
    Oa.misc.cachedPbkdf2 = function (a, b) {
        var c, d = Oa.misc.ca;
        return b = b || {},
        c = b.iter || 1e3,
        d = d[a] = d[a] || {},
        c = d[c] = d[c] || {
            firstSalt: b.salt &amp;&amp; b.salt.length ? b.salt.slice(0) : Oa.random.randomWords(2, 0)
        },
        d = b.salt === Ma ? c.firstSalt : b.salt,
        c[d] = c[d] || Oa.misc.pbkdf2(a, d, b.iter),
        {
            key: c[d].slice(0),
            salt: d.slice(0)
        }
    }
    ;
    var Xa, Ya = 0xdeadbeefcafe, Za = 15715070 == (16777215 &amp; Ya);
    Za &amp;&amp; "Microsoft Internet Explorer" == "Netscape" ? (k.prototype.am = n,
    Xa = 30) : Za &amp;&amp; "Netscape" != "Netscape" ? (k.prototype.am = m,
    Xa = 26) : (k.prototype.am = o,
    Xa = 28),
    k.prototype.DB = Xa,
    k.prototype.DM = (1 &lt;&lt; Xa) - 1,
    k.prototype.DV = 1 &lt;&lt; Xa;
    var $a = 52;
    k.prototype.FV = Math.pow(2, $a),
    k.prototype.F1 = $a - Xa,
    k.prototype.F2 = 2 * Xa - $a;
    var _a, ab, bb = "0123456789abcdefghijklmnopqrstuvwxyz", cb = new Array;
    for (_a = "0".charCodeAt(0),
    ab = 0; 9 &gt;= ab; ++ab)
        cb[_a++] = ab;
    for (_a = "a".charCodeAt(0),
    ab = 10; 36 &gt; ab; ++ab)
        cb[_a++] = ab;
    for (_a = "A".charCodeAt(0),
    ab = 10; 36 &gt; ab; ++ab)
        cb[_a++] = ab;
    L.prototype.convert = M,
    L.prototype.revert = N,
    L.prototype.reduce = O,
    L.prototype.mulTo = P,
    L.prototype.sqrTo = Q,
    S.prototype.convert = T,
    S.prototype.revert = U,
    S.prototype.reduce = V,
    S.prototype.mulTo = X,
    S.prototype.sqrTo = W,
    k.prototype.copyTo = r,
    k.prototype.fromInt = s,
    k.prototype.fromString = u,
    k.prototype.clamp = v,
    k.prototype.dlShiftTo = C,
    k.prototype.drShiftTo = D,
    k.prototype.lShiftTo = E,
    k.prototype.rShiftTo = F,
    k.prototype.subTo = G,
    k.prototype.multiplyTo = H,
    k.prototype.squareTo = I,
    k.prototype.divRemTo = J,
    k.prototype.invDigit = R,
    k.prototype.isEven = Y,
    k.prototype.exp = Z,
    k.prototype.toString = w,
    k.prototype.negate = x,
    k.prototype.abs = y,
    k.prototype.compareTo = z,
    k.prototype.bitLength = B,
    k.prototype.mod = K,
    k.prototype.modPowInt = $,
    k.ZERO = t(0),
    k.ONE = t(1),
    _.prototype.init = aa,
    _.prototype.next = ba;
    var db, eb, fb, gb = 256;
    if (null == eb) {
        eb = new Array,
        fb = 0;
        var hb;

        for (; gb &gt; fb;)
            hb = Math.floor(65536 * Math.random()),
            eb[fb++] = hb &gt;&gt;&gt; 8,
            eb[fb++] = 255 &amp; hb;
        fb = 0,
        ea()
    }
    ha.prototype.nextBytes = ga,
    ka.prototype.doPublic = ma,
    ka.prototype.setPublic = la,
    ka.prototype.encrypt = na,
    ja = function (a, b) {
        if (b &lt; a.length + 11)
            throw new Error("Message too long for RSA");
        for (var c = new Array(b), d = a.length - 1; d &gt;= 0 &amp;&amp; b &gt; 0;)
            c[--b] = a[d--];
        c[--b] = 0;
        for (var e = new ha, f = new Array; b &gt; 2;) {
            for (f[0] = 0; 0 == f[0];)
                e.nextBytes(f);
            c[--b] = f[0]
        }
        return c[--b] = 2,
        c[--b] = 0,
        new k(c)
    }
    ,
    ka.prototype.setPublic = function (a, b) {
        if (!(null != a &amp;&amp; null != b &amp;&amp; a.length &gt; 0 &amp;&amp; b.length &gt; 0))
            throw new Error("Invalid RSA public key");
        this.n = ia(a, 16),
        this.e = parseInt(b, 16)
    }
    ;
    var jb = b.Worldpay = {};
    jb.useForm = qa,
    jb.encrypt = sa,
    jb.setPublicKey = oa,
    jb.encryptData = va,
    "function" == typeof b.define &amp;&amp; b.define.amd &amp;&amp; b.define(function () {
        return jb
    });
    var kb = {
        cardNumber: "number",
        cvc: "cvc",
        expiryMonth: "exp-month",
        expiryYear: "exp-year",
        cardHolderName: "name"
    }
      , lb = ""
      , mb = "javascript";
    b["true"] = a
}({}, function () {
    return this
}());

function encrypt(a, b, c) {
    return Worldpay.encryptData(a, b, c);
}</value>
  </data>
  <data name="QueueITCaptcha4" xml:space="preserve">
    <value>var _clientInfo;
		var _session;
		var _beforeChallenge;

		function loadChallenge(checksum, challengeId, timestamp,input, zeroCount, sessionId, ip) {
		
			_session = {
			userId: "",
			challengeId: "",
			timestamp: "",
			parameters: {  Input :input, ZeroCount:zeroCount},
			checksum: "",
			sessionId: "",
			ip: "",
			solution: "",
			tags: [],
			stats: {
				duration: 0,
				tries: 1,
				difficulty: "1",
				userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0",
				screen: "1920 x 1080",
				browser: "Firefox",
				browserVersion: "66.0",
				isMobile: false,
				os: "Windows",
				osVersion: "10",
				cookiesEnabled: true
			}
		};
			
			var data = "{\"challengeId\":\"0d29bb4e-f595-47ae-a2f2-9297f2305a6a\",\"timestamp\":\"2019-04-10T16:02:54.1428985Z\",\"parameters\":{\"Input\":\"567a9bd4-f06b-4c5b-96d8-9a0986914686\",\"ZeroCount\":4},\"checksum\":\"If2E9FJmlh2iiIrN0JV8f9/9jkJpSfouraVoYRb6Dsc=______OXT3hdprFhHre3mnutbDuOgaYKFJXV5qAeflTsuL+q0=\",\"sessionId\":\"efcb1c8e-c242-47b5-8e08-02389d7a8eeb\",\"ip\":\"172.7.235.104\"}";
			
			_session.checksum = checksum;
				_session.challengeId = challengeId;
				_session.timestamp = timestamp;
				_session.sessionId = sessionId;
				_session.stats.difficulty = 1;
				_session.ip = ip;
															
					_beforeChallenge = (new Date()).getTime();
					return executeChallenge();
		}
			
			function executeChallenge() {
	//const input = "32d58c17-d646-4099-b56a-20543dd548ff"
		//const zeroCount = 4;
	_session.solution = run(_session.parameters.Input, _session.parameters.ZeroCount);
	return resolve();
}

function resolve() {
			var l = (new Date()).getTime();
            _session.stats.duration = l - _beforeChallenge;
			var resolvedParsed = _session.solution.hash + "." + _session.stats.duration+ "." + _session.solution.postfix;
			//let encoded = qitmCaptchaBase64(resolvedParsed, false);
			//_callback(encoded);
			
			return resolvedParsed;
		}

function run(input, zeroCount) {
		(function (I) {
			function w(c, a, d) {
				var l = 0,
				b = [],
				g = 0,
				f,
				n,
				k,
				e,
				h,
				q,
				y,
				p,
				m = !1,
				t = [],
				r = [],
				u,
				z = !1;
				d = d || {};
				f = d.encoding || "UTF8";
				u = d.numRounds || 1;
				if (u !== parseInt(u, 10) || 1 &gt; u)
					throw Error("numRounds must a integer &gt;= 1");
				if (0 === c.lastIndexOf("SHA-", 0))
					if (q = function (b, a) {
						return A(b, a, c)
					}, y = function (b, a, l, f) {
						var g,
						e;
						if ("SHA-224" === c || "SHA-256" === c)
							g = (a + 65 &gt;&gt;&gt; 9 &lt;&lt; 4)
								 + 15, e = 16;
							else
								throw Error("Unexpected error in SHA-2 implementation");
							for (; b.length &lt;= g; )
								b.push(0);
							b[a &gt;&gt;&gt; 5] |= 128 &lt;&lt; 24 - a % 32;
							a = a + l;
							b[g] = a &amp; 4294967295;
							b[g - 1] = a / 4294967296 | 0;
							l = b.length;
							for (a = 0; a &lt; l; a += e)
								f = A(b.slice(a, a + e), f, c);
							if ("SHA-224" === c)
								b = [f[0], f[1], f[2], f[3], f[4], f[5], f[6]];
							else if ("SHA-256" === c)
								b = f;
							else
								throw Error("Unexpected error in SHA-2 implementation");
							return b
						}, p = function (b) {
							return b.slice()
						}, "SHA-224" === c)h = 512, e = 224;
					else if ("SHA-256" === c)
						h = 512, e = 256;
					else
						throw Error("Chosen SHA variant is not supported");
				else
					throw Error("Chosen SHA variant is not supported");
				k = B(a, f);
				n = x(c);
				this.setHMACKey = function (b, a, g) {
					var e;
					if (!0 === m)
						throw Error("HMAC key already set");
					if (!0 === z)
						throw Error("Cannot set HMAC key after calling update");
					f = (g || {}).encoding || "UTF8";
					a = B(a, f)(b);
					b = a.binLen;
					a = a.value;
					e = h &gt;&gt;&gt; 3;
					g = e / 4 - 1;
					if (e &lt; b / 8) {
						for (a = y(a, b, 0, x(c)); a.length &lt;= g; )
							a.push(0);
						a[g] &amp;= 4294967040
					} else if (e &gt; b / 8) {
						for (; a.length &lt;= g; )
							a.push(0);
						a[g] &amp;= 4294967040
					}
					for (b = 0; b &lt;= g; b += 1)
						t[b] = a[b] ^ 909522486, r[b] = a[b] ^ 1549556828;
					n = q(t, n);
					l = h;
					m = !0
				};
				this.update = function (a) {
					var c,
					f,
					e,
					d = 0,
					p = h &gt;&gt;&gt; 5;
					c = k(a, b, g);
					a = c.binLen;
					f = c.value;
					c = a &gt;&gt;&gt; 5;
					for (e = 0; e &lt; c; e += p)
						d + h &lt;= a &amp;&amp; (n = q(f.slice(e, e + p), n), d += h);
					l += d;
					b = f.slice(d &gt;&gt;&gt;
							5);
					g = a % h;
					z = !0
				};
				this.getHash = function (a, f) {
					var d,
					h,
					k,
					q;
					if (!0 === m)
						throw Error("Cannot call getHash after setting HMAC key");
					k = C(f);
					switch (a) {
					case "HEX":
						d = function (a) {
							return D(a, e, k)
						};
						break;
					case "B64":
						d = function (a) {
							return E(a, e, k)
						};
						break;
					case "BYTES":
						d = function (a) {
							return F(a, e)
						};
						break;
					case "ARRAYBUFFER":
						try {
							h = new ArrayBuffer(0)
						} catch (v) {
							throw Error("ARRAYBUFFER not supported by this environment");
						}
						d = function (a) {
							return G(a, e)
						};
						break;
					default:
						throw Error("format must be HEX, B64, BYTES, or ARRAYBUFFER");
					}
					q = y(b.slice(), g, l, p(n));
					for (h = 1; h &lt; u; h += 1)
						q = y(q, e, 0, x(c));
					return d(q)
				};
				this.getHMAC = function (a, f) {
					var d,
					k,
					t,
					u;
					if (!1 === m)
						throw Error("Cannot call getHMAC without first setting HMAC key");
					t = C(f);
					switch (a) {
					case "HEX":
						d = function (a) {
							return D(a, e, t)
						};
						break;
					case "B64":
						d = function (a) {
							return E(a, e, t)
						};
						break;
					case "BYTES":
						d = function (a) {
							return F(a, e)
						};
						break;
					case "ARRAYBUFFER":
						try {
							d = new ArrayBuffer(0)
						} catch (v) {
							throw Error("ARRAYBUFFER not supported by this environment");
						}
						d = function (a) {
							return G(a, e)
						};
						break;
					default:
						throw Error("outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER");
					}
					k = y(b.slice(), g, l, p(n));
					u = q(r, x(c));
					u = y(k, e, h, u);
					return d(u)
				}
			}
			function m() {}
			function D(c, a, d) {
				var l = "";
				a /= 8;
				var b,
				g;
				for (b = 0; b &lt; a; b += 1)
					g = c[b &gt;&gt;&gt; 2] &gt;&gt;&gt; 8 * (3 + b % 4 * -1), l += "0123456789abcdef".charAt(g &gt;&gt;&gt; 4 &amp; 15) + "0123456789abcdef".charAt(g &amp; 15);
				return d.outputUpper ? l.toUpperCase() : l
			}
			function E(c, a, d) {
				var l = "",
				b = a / 8,
				g,
				f,
				n;
				for (g = 0; g &lt; b; g += 3)
					for (f = g + 1 &lt; b ? c[g + 1 &gt;&gt;&gt; 2] : 0, n = g + 2 &lt; b ? c[g + 2 &gt;&gt;&gt; 2] : 0, n = (c[g &gt;&gt;&gt; 2] &gt;&gt;&gt; 8 * (3 + g % 4 * -1) &amp; 255) &lt;&lt; 16 | (f &gt;&gt;&gt; 8 * (3 + (g + 1) % 4 * -1) &amp; 255) &lt;&lt; 8 | n &gt;&gt;&gt; 8 * (3 + (g + 2) % 4 * -1) &amp; 255, f = 0; 4 &gt; f; f += 1)
						8 * g + 6 * f &lt;= a ? l += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(n &gt;&gt;&gt;
							6 * (3 - f) &amp; 63) : l += d.b64Pad;
				return l
			}
			function F(c, a) {
				var d = "",
				l = a / 8,
				b,
				g;
				for (b = 0; b &lt; l; b += 1)
					g = c[b &gt;&gt;&gt; 2] &gt;&gt;&gt; 8 * (3 + b % 4 * -1) &amp; 255, d += String.fromCharCode(g);
				return d
			}
			function G(c, a) {
				var d = a / 8,
				l,
				b = new ArrayBuffer(d),
				g;
				g = new Uint8Array(b);
				for (l = 0; l &lt; d; l += 1)
					g[l] = c[l &gt;&gt;&gt; 2] &gt;&gt;&gt; 8 * (3 + l % 4 * -1) &amp; 255;
				return b
			}
			function C(c) {
				var a = {
					outputUpper: !1,
					b64Pad: "=",
					shakeLen: -1
				};
				c = c || {};
				a.outputUpper = c.outputUpper || !1;
				!0 === c.hasOwnProperty("b64Pad") &amp;&amp; (a.b64Pad = c.b64Pad);
				if ("boolean" !== typeof a.outputUpper)
					throw Error("Invalid outputUpper formatting option");
				if ("string" !== typeof a.b64Pad)
					throw Error("Invalid b64Pad formatting option");
				return a
			}
			function B(c, a) {
				var d;
				switch (a) {
				case "UTF8":
				case "UTF16BE":
				case "UTF16LE":
					break;
				default:
					throw Error("encoding must be UTF8, UTF16BE, or UTF16LE");
				}
				switch (c) {
				case "HEX":
					d = function (a, b, c) {
						var f = a.length,
						d,
						k,
						e,
						h,
						q;
						if (0 !== f % 2)
							throw Error("String of HEX type must be in byte increments");
						b = b || [0];
						c = c || 0;
						q = c &gt;&gt;&gt; 3;
						for (d = 0; d &lt; f; d += 2) {
							k = parseInt(a.substr(d, 2), 16);
							if (isNaN(k))
								throw Error("String of HEX type contains invalid characters");
							h = (d &gt;&gt;&gt; 1) + q;
							for (e = h &gt;&gt;&gt; 2; b.length &lt;= e; )
								b.push(0);
							b[e] |= k &lt;&lt; 8 * (3 + h % 4 * -1)
						}
						return {
							value: b,
							binLen: 4 * f + c
						}
					};
					break;
				case "TEXT":
					d = function (c, b, d) {
						var f,
						n,
						k = 0,
						e,
						h,
						q,
						m,
						p,
						r;
						b = b || [0];
						d = d || 0;
						q = d &gt;&gt;&gt; 3;
						if ("UTF8" === a)
							for (r = 3, e = 0; e &lt; c.length; e += 1)
								for (f = c.charCodeAt(e), n = [], 128 &gt; f ? n.push(f) : 2048 &gt; f ? (n.push(192 | f &gt;&gt;&gt; 6), n.push(128 | f &amp; 63)) : 55296 &gt; f || 57344 &lt;= f ? n.push(224 | f &gt;&gt;&gt; 12, 128 | f &gt;&gt;&gt; 6 &amp; 63, 128 | f &amp; 63) : (e += 1, f = 65536 + ((f &amp; 1023) &lt;&lt; 10 | c.charCodeAt(e) &amp; 1023), n.push(240 | f &gt;&gt;&gt; 18, 128 | f &gt;&gt;&gt; 12 &amp; 63, 128 | f &gt;&gt;&gt; 6 &amp; 63, 128 | f &amp; 63)), h = 0; h &lt; n.length; h += 1) {
									p = k +
										q;
									for (m = p &gt;&gt;&gt; 2; b.length &lt;= m; )
										b.push(0);
									b[m] |= n[h] &lt;&lt; 8 * (r + p % 4 * -1);
									k += 1
								}
						else if ("UTF16BE" === a || "UTF16LE" === a)
							for (r = 2, n = "UTF16LE" === a &amp;&amp; !0 || "UTF16LE" !== a &amp;&amp; !1, e = 0; e &lt; c.length; e += 1) {
								f = c.charCodeAt(e);
								!0 === n &amp;&amp; (h = f &amp; 255, f = h &lt;&lt; 8 | f &gt;&gt;&gt; 8);
								p = k + q;
								for (m = p &gt;&gt;&gt; 2; b.length &lt;= m; )
									b.push(0);
								b[m] |= f &lt;&lt; 8 * (r + p % 4 * -1);
								k += 2
							}
						return {
							value: b,
							binLen: 8 * k + d
						}
					};
					break;
				case "B64":
					d = function (a, b, c) {
						var f = 0,
						d,
						k,
						e,
						h,
						q,
						m,
						p;
						if (-1 === a.search(/^[a-zA-Z0-9=+\/]+$/))
							throw Error("Invalid character in base-64 string");
						k = a.indexOf("=");
						a = a.replace(/\=/g,
								"");
						if (-1 !== k &amp;&amp; k &lt; a.length)
							throw Error("Invalid '=' found in base-64 string");
						b = b || [0];
						c = c || 0;
						m = c &gt;&gt;&gt; 3;
						for (k = 0; k &lt; a.length; k += 4) {
							q = a.substr(k, 4);
							for (e = h = 0; e &lt; q.length; e += 1)
								d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(q[e]), h |= d &lt;&lt; 18 - 6 * e;
							for (e = 0; e &lt; q.length - 1; e += 1) {
								p = f + m;
								for (d = p &gt;&gt;&gt; 2; b.length &lt;= d; )
									b.push(0);
								b[d] |= (h &gt;&gt;&gt; 16 - 8 * e &amp; 255) &lt;&lt; 8 * (3 + p % 4 * -1);
								f += 1
							}
						}
						return {
							value: b,
							binLen: 8 * f + c
						}
					};
					break;
				case "BYTES":
					d = function (a, b, c) {
						var d,
						n,
						k,
						e,
						h;
						b = b || [0];
						c = c || 0;
						k = c &gt;&gt;&gt; 3;
						for (n = 0; n &lt; a.length; n +=
							1)
							d = a.charCodeAt(n), h = n + k, e = h &gt;&gt;&gt; 2, b.length &lt;= e &amp;&amp; b.push(0), b[e] |= d &lt;&lt; 8 * (3 + h % 4 * -1);
						return {
							value: b,
							binLen: 8 * a.length + c
						}
					};
					break;
				case "ARRAYBUFFER":
					try {
						d = new ArrayBuffer(0)
					} catch (l) {
						throw Error("ARRAYBUFFER not supported by this environment");
					}
					d = function (a, b, c) {
						var d,
						n,
						k,
						e,
						h;
						b = b || [0];
						c = c || 0;
						n = c &gt;&gt;&gt; 3;
						h = new Uint8Array(a);
						for (d = 0; d &lt; a.byteLength; d += 1)
							e = d + n, k = e &gt;&gt;&gt; 2, b.length &lt;= k &amp;&amp; b.push(0), b[k] |= h[d] &lt;&lt; 8 * (3 + e % 4 * -1);
						return {
							value: b,
							binLen: 8 * a.byteLength + c
						}
					};
					break;
				default:
					throw Error("format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER");
				}
				return d
			}
			function r(c, a) {
				return c &gt;&gt;&gt; a | c &lt;&lt; 32 - a
			}
			function J(c, a, d) {
				return c &amp; a ^ ~c &amp; d
			}
			function K(c, a, d) {
				return c &amp; a ^ c &amp; d ^ a &amp; d
			}
			function L(c) {
				return r(c, 2) ^ r(c, 13) ^ r(c, 22)
			}
			function M(c) {
				return r(c, 6) ^ r(c, 11) ^ r(c, 25)
			}
			function N(c) {
				return r(c, 7) ^ r(c, 18) ^ c &gt;&gt;&gt; 3
			}
			function O(c) {
				return r(c, 17) ^ r(c, 19) ^ c &gt;&gt;&gt; 10
			}
			function P(c, a) {
				var d = (c &amp; 65535) + (a &amp; 65535);
				return ((c &gt;&gt;&gt; 16) + (a &gt;&gt;&gt; 16) + (d &gt;&gt;&gt; 16) &amp; 65535) &lt;&lt; 16 | d &amp; 65535
			}
			function Q(c, a, d, l) {
				var b = (c &amp; 65535) + (a &amp; 65535) + (d &amp; 65535) + (l &amp; 65535);
				return ((c &gt;&gt;&gt; 16) + (a &gt;&gt;&gt; 16) + (d &gt;&gt;&gt; 16) + (l &gt;&gt;&gt; 16) + (b &gt;&gt;&gt;
						16) &amp; 65535) &lt;&lt; 16 | b &amp; 65535
			}
			function R(c, a, d, l, b) {
				var g = (c &amp; 65535) + (a &amp; 65535) + (d &amp; 65535) + (l &amp; 65535) + (b &amp; 65535);
				return ((c &gt;&gt;&gt; 16) + (a &gt;&gt;&gt; 16) + (d &gt;&gt;&gt; 16) + (l &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (g &gt;&gt;&gt; 16) &amp; 65535) &lt;&lt; 16 | g &amp; 65535
			}
			function x(c) {
				var a = [],
				d;
				if (0 === c.lastIndexOf("SHA-", 0))
					switch (a = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], d = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], c) {
					case "SHA-224":
						break;
					case "SHA-256":
						a = d;
						break;
					case "SHA-384":
						a = [new m, new m,
							new m, new m, new m, new m, new m, new m];
						break;
					case "SHA-512":
						a = [new m, new m, new m, new m, new m, new m, new m, new m];
						break;
					default:
						throw Error("Unknown SHA variant");
					}
				else
					throw Error("No SHA variants supported");
				return a
			}
			function A(c, a, d) {
				var l,
				b,
				g,
				f,
				n,
				k,
				e,
				h,
				m,
				r,
				p,
				w,
				t,
				x,
				u,
				z,
				A,
				B,
				C,
				D,
				E,
				F,
				v = [],
				G;
				if ("SHA-224" === d || "SHA-256" === d)
					r = 64, w = 1, F = Number, t = P, x = Q, u = R, z = N, A = O, B = L, C = M, E = K, D = J, G = H;
				else
					throw Error("Unexpected error in SHA-2 implementation");
				d = a[0];
				l = a[1];
				b = a[2];
				g = a[3];
				f = a[4];
				n = a[5];
				k = a[6];
				e = a[7];
				for (p =
						0; p &lt; r; p += 1)
					16 &gt; p ? (m = p * w, h = c.length &lt;= m ? 0 : c[m], m = c.length &lt;= m + 1 ? 0 : c[m + 1], v[p] = new F(h, m)) : v[p] = x(A(v[p - 2]), v[p - 7], z(v[p - 15]), v[p - 16]), h = u(e, C(f), D(f, n, k), G[p], v[p]), m = t(B(d), E(d, l, b)), e = k, k = n, n = f, f = t(g, h), g = b, b = l, l = d, d = t(h, m);
				a[0] = t(d, a[0]);
				a[1] = t(l, a[1]);
				a[2] = t(b, a[2]);
				a[3] = t(g, a[3]);
				a[4] = t(f, a[4]);
				a[5] = t(n, a[5]);
				a[6] = t(k, a[6]);
				a[7] = t(e, a[7]);
				return a
			}
			var H;
			H = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206,
				2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
				2756734187, 3204031479, 3329325298];
			"function" === typeof define &amp;&amp; define.amd ? define(function () {
				return w
			}) : "undefined" !== typeof exports ? ("undefined" !== typeof module &amp;&amp; module.exports &amp;&amp; (module.exports = w), exports = w) : I.jsSHA = w
		})(this);
		var zeroes = "";
		for (var i = 0; i &lt; zeroCount; i++) {
			zeroes += "0";
		}

		var loop = true;
		var postfix = 0;
		while (loop) {
				postfix++;
				var shaObj = new jsSHA("SHA-256", "TEXT");
				shaObj.update(input);
				shaObj.update(postfix.toString());
				var hash = shaObj.getHash("HEX");

				if (hash.indexOf(zeroes) === 0) {
					loop = false;
					return {
						postfix: postfix,
						hash: hash
					};
				}
			}
	}</value>
  </data>
</root>